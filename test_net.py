import pytest
import time
import trio
import trio.testing

import json

import hypothesis as hyp
import hypothesis.strategies as st

import net
import logging

logging.basicConfig(level=logging.WARNING)

keys = st.one_of(st.text(min_size=1, max_size=40))
values = st.one_of(
    st.integers(),
    st.floats(allow_nan=False),
    st.text(min_size=1, max_size=40),
    st.booleans()
)

serializable = st.dictionaries(keys, values, max_size=20)

async def _send_string_by_chunks(stream, string, *, chunk_len=10):
    # length of chunks
    i = 0
    while i < len(string):
        j = i + chunk_len
        if j > len(string):
            j = len(string)
        await stream.send_all(bytes(string[i:j], encoding='utf-8'))
        # await trio.sleep(0)
        i = j

async def _assert_reading(stream, objects):
    i = 0
    with trio.move_on_after(1) as cancel_scope:
        while i < len(objects):
            assert await stream.read() == objects[i]
            i += 1

    assert cancel_scope.cancelled_caught is False

@hyp.given(st.lists(serializable, max_size=10))
@hyp.settings(deadline=500, max_examples=50)
async def test_read_chuncky_connection(objects):
    """ Make sure that JSON stream works when texts doesn't come in nicely """
    with trio.move_on_after(1) as cancel_scope:
        a, stream_controlled = trio.testing.memory_stream_pair()
        stream_tested = net.JSONStream(a)
        string = '\n'.join(json.dumps(obj) for obj in objects) + '\n'

        async with trio.open_nursery() as n:
            n.start_soon(_send_string_by_chunks, stream_controlled, string)
            n.start_soon(_assert_reading, stream_tested, objects)
    assert cancel_scope.cancelled_caught is False


@hyp.given(st.lists(serializable, max_size=10))
async def test_read_multiple_object_per_message(objects):
    """ Make sure that JSON stream can read multiple objects in one read (one
    message) """

    with trio.move_on_after(1) as cancel_scope:
        a, stream_controlled = trio.testing.memory_stream_pair()
        stream_tested = net.JSONStream(a)
        string = '\n'.join(json.dumps(obj) for obj in objects) + '\n'
        async with trio.open_nursery() as n:
            n.start_soon(_assert_reading, stream_tested, objects)
            n.start_soon(stream_controlled.send_all, bytes(string, encoding='utf-8'))

    assert cancel_scope.cancelled_caught is False


async def test_timed_stream_write_t_key_exception():
    """ write shouldn't allow object with key 't' already set """
    a, b = trio.testing.memory_stream_pair()
    stream_tested = net.TimedStream(a)

    with pytest.raises(ValueError):
        await stream_tested.write({net.TIME_KEY: 200})

@hyp.given(st.lists(st.floats(min_value=0, max_value=0.005), min_size=1, max_size=10))
async def test_timed_stream_message_discarding(delays):
    """ Make sure that old message are discarded

    It waits a "random" amount of time (generated by hypothesis) before sending
    every message. Because we know every delay ahead of time, we can deduce
    which order the messages *should* arrive.

    We set the 'order' key in the message before sending it, and then we check
    that it messages arrive with an increasing 'order'.

    Note that this doesn't even rely on having a reliable stream. We don't care
    whether we get every message, we only care that they arrive in the right
    order. 

    In total, it sends len(delays) messages (but always_newer isn't guaranteed
    to receive that many)
    """

    # make sure that in total, we don't wait too much
    hyp.assume(sum(delays) < .01)

    a, b = trio.testing.memory_stream_pair()
    stream_tested = net.TimedStream(a)
    stream_controlled = net.TimedStream(b)

    async def always_newer(stream, messages_count):
        last_order = -1
        for _ in range(messages_count):
            obj = await stream.read()
            assert obj['order'] > last_order
            last_timestamp = obj['order'] 

    async def delayed_send(stream, obj, delay):
        await trio.sleep(delay)
        await stream.write(obj)

    sorted_delays = delays.copy()
    sorted_delays.sort()

    async with trio.open_nursery() as n:
        for i, delay in enumerate(delays):
            n.start_soon(
                delayed_send,
                stream_controlled,
                {'order': sorted_delays.index(delay)},
                delays[i%len(delays)])

        n.start_soon(always_newer, stream_tested, len(delays))